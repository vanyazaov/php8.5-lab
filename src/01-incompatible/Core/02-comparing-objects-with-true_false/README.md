========================================

#### Backward Incompatible Changes

========================================

##### Core:

Loosely comparing uncomparable objects (e.g. enums, \CurlHandle and other internal classes) to booleans was previously inconsistent. If compared to a boolean literal **$object == true**, it would behave the same way as **(bool) $object**. If compared to a statically unknown value **$object == $true**, it would always return **false**. This behavior was consolidated to always follow the behavior of **(bool) $object**.

-------------------------------------------------------------------------------------------------------------------------------

### **Краткий смысл изменения**

До PHP 8.5 существовала **нелогичная и противоречивая логика** при "нестрогом" сравнении (`==`) объектов, которые нельзя сравнивать (например, перечислений — Enums, ресурсов в виде объектов типа `CurlHandle` и других внутренних классов), с булевыми значениями.

**Теперь эта логика унифицирована:** Результат сравнения `$object == $boolean` всегда будет таким же, как результат приведения объекта к булевому типу — `(bool) $object`.

---

### **Подробное объяснение с примерами**

#### **1. Какие объекты считаются "uncomparable"?**

Это объекты, для которых PHP **не позволяет использовать операторы сравнения** (`>`, `<`, `>=`, `<=`, `==`, `!=`). При попытке такого сравнения генерируется `TypeError` (в строгом режиме) или результат считается `false` (в нестрогом). К ним относятся:

*   **Объекты внутренних классов**, не реализующих механизм сравнения: `CurlHandle`, `GMP` (в некоторых контекстах), `Socket`, и многие другие "ресурсные" объекты.
*   **Enums (Перечисления)**, особенно "чистые" (`Pure Enum`), которые не имеют скалярного "значения" для сравнения.

```php
$ch = curl_init(); // $ch теперь объект CurlHandle
$true = true;

// Это вызовет TypeError: curl_init() == true
// Потому что CurlHandle нельзя сравнивать
```

#### **2. Какое было "неконсистентное поведение" ДО PHP 8.5?**

Ключевая проблема была в разнице между сравнением с **буквальным значением** (`true`/`false`) и **переменной**, содержащей это значение.

**Пример до PHP 8.5:**

```php
enum Status {
    case PENDING;
    case DONE;
}

$object = Status::PENDING; // Объект Enum
$true = true; // Переменная, содержащая true

// Сравнение с БУКВАЛОМ true
var_dump($object == true);
// До 8.5: bool(true)
// Логика: приводило объект к bool: (bool)$object -> true, затем сравнивало true == true.

// Сравнение с ПЕРЕМЕННОЙ, содержащей true
var_dump($object == $true);
// До 8.5: bool(false)
// Логика: PHP пытался сравнить объект и переменную. Типы разные, объект несравним.
//         Включалась общая логика для несравнимых типов -> возвращалось false.
```

**Итог до PHP 8.5:**
*   `$object == true` -> `true` (ведет себя как `(bool)$object`)
*   `$object == $true` -> `false` (ведет себя как "типы несравнимы")

Это была явная **инконсистентность**, потому что семантически `true` и `$true` (со значением `true`) — это одно и то же.

#### **3. Что изменилось В PHP 8.5?**

Поведение было **консолидировано** (унифицировано). Было решено, что первое поведение (приведение объекта к `bool`) более логично и полезно, чем всегда возвращать `false`.

**Пример после PHP 8.5:**

```php
enum Status {
    case PENDING;
    case DONE;
}

$object = Status::PENDING;
$true = true;

// Сравнение с БУКВАЛОМ true
var_dump($object == true); // bool(true)

// Сравнение с ПЕРЕМЕННОЙ, содержащей true
var_dump($object == $true); // bool(true) <- ИЗМЕНИЛОСЬ!

// Сравнение с false (объекты в PHP всегда приводятся к true)
var_dump($object == false); // bool(false)
var_dump($object == $false); // bool(false)
```

**Новая единая логика:**
1.  При нестрогом сравнении (`==`) объекта, не поддерживающего сравнение, с любым булевым значением (`true`, `false`, переменной, результатом функции).
2.  PHP **неявно приводит объект к булевому типу** (`(bool) $object`).
3.  Затем сравнивает два получившихся булевых значения.

Поскольку в PHP любой объект (включая пустой `stdClass` или case Enum) при приведении к `bool` дает `true`, то:
*   `$object == true` -> `(bool)$object` -> `true` -> `true == true` -> **`true`**
*   `$object == false` -> `(bool)$object` -> `true` -> `true == false` -> **`false`**

---

### **Почему это важно и практические последствия**

1.  **Устранение ошибок в коде:** Код, который зависел от старого поведения (особенно сравнение с переменной), может изменить свою логику. Если вы писали `if ($enum == $isActive)`, и ожидали `false` для несравнимых типов, теперь условие может неожиданно выполниться.
2.  **Предсказуемость:** Поведение стало логичным и предсказуемым. Сравнение с булевым значением теперь семантически эквивалентно проверке `(bool)$object === $booleanValue`.
3.  **Строгое vs Нестрогое сравнение:** Это изменение касается **только нестрогого сравнения (`==`)**. Строгое сравнение (`===`) работает по-прежнему и всегда вернет `false` при сравнении объекта и булевого значения, потому что типы разные.

```php
$object = Status::PENDING;
var_dump($object === true); // bool(false), и всегда будет false
```

### **Рекомендация для разработчиков**

*   **Проанализируйте код:** Найдите в своем коде все нестрогие сравнения (`==`, `!=`) объектов (особенно Enums и ресурсных объектов) с булевыми переменными или значениями.
*   **Проверьте логику:** Убедитесь, что новое поведение (всегда `true` при сравнении с `true` для любого объекта) соответствует ожидаемой логике вашей программы.
*   **Рассмотрите строгое сравнение:** Если ваша логика зависит от типов, используйте `===` и `!==`. Это сделает код более устойчивым и явным.
*   **Явное приведение типов:** Для ясности лучше использовать явное приведение: `(bool)$object === $value`.

Это изменение — часть долгосрочной работы команды PHP по устранению неконсистентностей и "причуд" языка, делая его поведение более рациональным и понятным.