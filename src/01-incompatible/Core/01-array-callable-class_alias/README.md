========================================

#### Backward Incompatible Changes

========================================

##### Core:

It is no longer possible to use "array" and "callable" as class alias names in class_alias().

-------------------------------------------------------------------------------------------------------------------------------

### **Краткий ответ**

Функция `class_alias()` создает **псевдоним (алиас)** для класса. В данном случае она пытается создать псевдоним `'array'` для класса `Test::class`. Это **чрезвычайно опасная операция**, которая может сломать ваш код и поведение PHP.

### **Пошаговое объяснение**

#### 1. Что такое `class_alias()`?
```php
bool class_alias(string $original, string $alias, bool $autoload = true)
```
- Создает псевдоним с именем `$alias` для класса `$original`
- После этого можно использовать оба имени для создания объектов
- Возвращает `true` при успехе, `false` при ошибке

#### 2. Что такое `Test::class`?
- `::class` - это специальная константа, доступная с PHP 5.5
- Возвращает полное имя класса (с namespace, если он есть)
- Например, если класс `Test` находится в namespace `App\Models`, то `Test::class` вернет строку `'App\Models\Test'`

#### 3. Что происходит в этом конкретном коде?

```php
class_alias(Test::class, 'array');
```

**Попытка:** Создать псевдоним `array` для класса `Test`.

**Ожидаемый результат (если бы это работало):**
```php
$obj1 = new Test();      // Создает объект Test
$obj2 = new array();     // Тоже создает объект Test (через псевдоним)
// $obj1 и $obj2 были бы объектами одного класса
```

### **Проблема и почему это опасно**

#### Проблема №1: `array` - это зарезервированное ключевое слово
`array` в PHP - это:
1. **Тип данных** (как `int`, `string`, `bool`)
2. **Конструктор языка** для создания массивов: `$arr = array(1, 2, 3);`
3. **Зарезервированное ключевое слово**

#### Проблема №2: Что на самом деле произойдет?

#### **Версия PHP < 8.0:**
Код может "сработать", но приведет к непредсказуемым последствиям:
```php
// До PHP 8.0 это могло скомпилироваться
class_alias(Test::class, 'array');

// Но затем возникает хаос:
$arr = array(1, 2, 3);  // Что это теперь? Массив или объект Test?
$test = new array();    // Создает объект Test, а не массив

// type-hinting ломается:
function process(array $data) { ... }
// PHP теперь не знает, что такое "array" в этом контексте
```

#### **Версия PHP ≥ 8.5:**
Начиная с PHP 8.5, такой код вызовет **фатальную ошибку**:

```
Fatal error: Cannot use 'array' as class name as it is reserved
```

PHP стал строже и запрещает использовать зарезервированные имена для классов.

### **Зачем вообще использовать class_alias()?**

1. **Обратная совместимость:**
   
   ```php
   // Старое имя класса (устаревшее)
   class OldClassName { ... }
   
   // Новое имя класса
   class NewClassName { ... }
   
   // Создаем алиас для обратной совместимости
   class_alias(NewClassName::class, 'OldClassName');
   ```
   
2. **Сокращение длинных имен:**
   ```php
   class_alias('Vendor\Package\VeryLongClassName', 'ShortName');
   ```

3. **Создание фасадов или псевдонимов в фреймворках**

### **Важные ограничения для class_alias()**

1. **Нельзя использовать для:**
   - Зарезервированных слов (`array`, `string`, `int`, `bool`, и т.д.)
   - Встроенных классов (`stdClass`, `Exception`, и т.д.)
   - Ключевых слов языка

2. **Алиас действует глобально** - после создания, он доступен во всем скрипте

3. **Нельзя удалить или переопределить** существующий алиас

## **Вывод**

Код `class_alias(Test::class, 'array');`:

1. **В PHP < 8.0:** Попытается создать алиас, что приведет к непредсказуемому поведению и может сломать работу с массивами
2. **В PHP ≥ 8.5:** Вызовет фатальную ошибку во время выполнения
3. **В любом случае:** Это **антипаттерн**, который никогда не должен использоваться в реальном коде

**Правило:** Никогда не используйте зарезервированные слова PHP в качестве имен классов, интерфейсов, трейтов или их алиасов.